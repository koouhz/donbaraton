CREATE OR REPLACE FUNCTION fn_registrar_auditoria(
    p_usuario VARCHAR,
    p_modulo VARCHAR,
    p_accion VARCHAR,
    p_detalles TEXT
) RETURNS VARCHAR AS $$
DECLARE
    v_auditoria_id VARCHAR;
BEGIN
    v_auditoria_id := gen_random_uuid()::text;
    INSERT INTO public.auditoria (id, usuario, modulo, accion, detalles, estado)
    VALUES (v_auditoria_id, p_usuario, p_modulo, p_accion, p_detalles, 'EXITOSO');
    RETURN v_auditoria_id;
END;
$$ LANGUAGE plpgsql;


-- 1. CREAR CARGO
CREATE OR REPLACE FUNCTION fn_crear_cargo(
    p_nombre VARCHAR,
    p_descripcion TEXT,
    p_usuario_auditoria VARCHAR
) RETURNS INTEGER AS $$
DECLARE
    v_id INTEGER;
    v_auditoria_id VARCHAR;
BEGIN
    v_auditoria_id := fn_registrar_auditoria(p_usuario_auditoria, 'RRHH', 'CREAR', 'Cargo: ' || p_nombre);

    INSERT INTO public.cargos (nombre, descripcion, auditoria_id)
    VALUES (p_nombre, p_descripcion, v_auditoria_id)
    RETURNING id INTO v_id;

    RETURN v_id;
END;
$$ LANGUAGE plpgsql;

-- 2. LEER CARGOS
CREATE OR REPLACE FUNCTION fn_leer_cargos()
RETURNS TABLE (id INTEGER, nombre VARCHAR, descripcion TEXT) AS $$
BEGIN
    RETURN QUERY 
    SELECT c.id, c.nombre, c.descripcion 
    FROM public.cargos c 
    WHERE c.estadoa = true;
END;
$$ LANGUAGE plpgsql;

-- 3. ACTUALIZAR CARGO
CREATE OR REPLACE FUNCTION fn_actualizar_cargo(
    p_id INTEGER,
    p_nombre VARCHAR,
    p_descripcion TEXT,
    p_usuario_auditoria VARCHAR
) RETURNS BOOLEAN AS $$
DECLARE
    v_auditoria_id VARCHAR;
BEGIN
    v_auditoria_id := fn_registrar_auditoria(p_usuario_auditoria, 'RRHH', 'EDITAR', 'Cargo ID: ' || p_id);

    UPDATE public.cargos
    SET nombre = COALESCE(p_nombre, nombre),
        descripcion = COALESCE(p_descripcion, descripcion),
        auditoria_id = v_auditoria_id,
        fechaa = NOW()
    WHERE id = p_id;
    RETURN FOUND;
END;
$$ LANGUAGE plpgsql;

-- 4. ELIMINAR CARGO (Lógico)
CREATE OR REPLACE FUNCTION fn_eliminar_cargo(
    p_id INTEGER,
    p_usuario_auditoria VARCHAR
) RETURNS BOOLEAN AS $$
DECLARE
    v_auditoria_id VARCHAR;
BEGIN
    v_auditoria_id := fn_registrar_auditoria(p_usuario_auditoria, 'RRHH', 'ELIMINAR', 'Cargo ID: ' || p_id);
    
    UPDATE public.cargos SET estadoa = false, auditoria_id = v_auditoria_id, fechaa = NOW()
    WHERE id = p_id;
    RETURN FOUND;
END;
$$ LANGUAGE plpgsql;


-- 1. CREAR EMPLEADO
CREATE OR REPLACE FUNCTION fn_crear_empleado(
    p_ci VARCHAR,
    p_nombres VARCHAR,
    p_paterno VARCHAR,
    p_materno VARCHAR,
    p_fecha_nac DATE,
    p_sexo BOOLEAN, -- true=M, false=F (ejemplo)
    p_telefono VARCHAR,
    p_email VARCHAR,
    p_cargo_id INTEGER,
    p_salario NUMERIC,
    p_usuario_auditoria VARCHAR
) RETURNS VARCHAR AS $$
DECLARE
    v_id VARCHAR;
    v_auditoria_id VARCHAR;
BEGIN
    -- Validar CI único
    IF EXISTS (SELECT 1 FROM public.empleados WHERE ci = p_ci) THEN
        RAISE EXCEPTION 'Ya existe un empleado con CI %', p_ci;
    END IF;

    v_auditoria_id := fn_registrar_auditoria(p_usuario_auditoria, 'RRHH', 'CREAR', 'Empleado: ' || p_nombres || ' ' || p_paterno);
    v_id := gen_random_uuid()::text;

    INSERT INTO public.empleados (
        id, ci, nombres, apellido_paterno, apellido_materno, fecha_nacimiento, sexo, 
        telefono, email, cargo_id, salario, estado, fecha_contratacion, auditoria_id
    ) VALUES (
        v_id, p_ci, p_nombres, p_paterno, p_materno, p_fecha_nac, p_sexo,
        p_telefono, p_email, p_cargo_id, p_salario, 'ACTIVO', CURRENT_DATE, v_auditoria_id
    );

    RETURN v_id;
END;
$$ LANGUAGE plpgsql;

-- 2. LEER EMPLEADOS
CREATE OR REPLACE FUNCTION fn_leer_empleados(
    p_buscar TEXT DEFAULT NULL
) RETURNS TABLE (
    id VARCHAR, nombre_completo TEXT, ci VARCHAR, cargo VARCHAR, estado VARCHAR
) AS $$
BEGIN
    RETURN QUERY 
    SELECT 
        e.id, 
        (e.nombres || ' ' || e.apellido_paterno || ' ' || COALESCE(e.apellido_materno, ''))::TEXT,
        e.ci,
        c.nombre as cargo,
        e.estado
    FROM public.empleados e
    LEFT JOIN public.cargos c ON e.cargo_id = c.id
    WHERE e.estadoa = true
    AND (p_buscar IS NULL OR e.ci ILIKE '%' || p_buscar || '%' OR e.nombres ILIKE '%' || p_buscar || '%');
END;
$$ LANGUAGE plpgsql;

-- 3. ACTUALIZAR EMPLEADO
CREATE OR REPLACE FUNCTION fn_actualizar_empleado(
    p_id VARCHAR,
    p_telefono VARCHAR,
    p_email VARCHAR,
    p_cargo_id INTEGER,
    p_salario NUMERIC,
    p_usuario_auditoria VARCHAR
) RETURNS BOOLEAN AS $$
DECLARE
    v_auditoria_id VARCHAR;
BEGIN
    v_auditoria_id := fn_registrar_auditoria(p_usuario_auditoria, 'RRHH', 'EDITAR', 'Empleado ID: ' || p_id);

    UPDATE public.empleados
    SET telefono = COALESCE(p_telefono, telefono),
        email = COALESCE(p_email, email),
        cargo_id = COALESCE(p_cargo_id, cargo_id),
        salario = COALESCE(p_salario, salario),
        auditoria_id = v_auditoria_id,
        fechaa = NOW()
    WHERE id = p_id;
    RETURN FOUND;
END;
$$ LANGUAGE plpgsql;

-- 4. ELIMINAR EMPLEADO (Lógico - RH-NEW2)
CREATE OR REPLACE FUNCTION fn_eliminar_empleado(
    p_id VARCHAR,
    p_usuario_auditoria VARCHAR
) RETURNS BOOLEAN AS $$
DECLARE
    v_auditoria_id VARCHAR;
BEGIN
    v_auditoria_id := fn_registrar_auditoria(p_usuario_auditoria, 'RRHH', 'ELIMINAR', 'Baja empleado ID: ' || p_id);
    
    UPDATE public.empleados 
    SET estado = 'INACTIVO', estadoa = false, auditoria_id = v_auditoria_id, fechaa = NOW()
    WHERE id = p_id;
    
    -- También deberíamos desactivar su usuario si tiene uno
    UPDATE public.usuarios SET estado = 'INACTIVO' WHERE empleado_id = p_id;
    
    RETURN FOUND;
END;
$$ LANGUAGE plpgsql;


-- 1. CREAR ROL
CREATE OR REPLACE FUNCTION fn_crear_rol(
    p_nombre VARCHAR,
    p_descripcion TEXT,
    p_usuario_auditoria VARCHAR
) RETURNS INTEGER AS $$
DECLARE
    v_id INTEGER;
    v_auditoria_id VARCHAR;
BEGIN
    v_auditoria_id := fn_registrar_auditoria(p_usuario_auditoria, 'SEGURIDAD', 'CREAR', 'Rol: ' || p_nombre);

    INSERT INTO public.roles (nombre, descripcion, auditoria_id)
    VALUES (p_nombre, p_descripcion, v_auditoria_id)
    RETURNING id INTO v_id;
    RETURN v_id;
END;
$$ LANGUAGE plpgsql;

-- 2. LEER ROLES
CREATE OR REPLACE FUNCTION fn_leer_roles()
RETURNS TABLE (id INTEGER, nombre VARCHAR, descripcion TEXT) AS $$
BEGIN
    RETURN QUERY SELECT r.id, r.nombre, r.descripcion FROM public.roles r WHERE r.estadoa = true;
END;
$$ LANGUAGE plpgsql;

-- 3. ACTUALIZAR ROL
CREATE OR REPLACE FUNCTION fn_actualizar_rol(
    p_id INTEGER,
    p_nombre VARCHAR,
    p_descripcion TEXT,
    p_usuario_auditoria VARCHAR
) RETURNS BOOLEAN AS $$
DECLARE
    v_auditoria_id VARCHAR;
BEGIN
    v_auditoria_id := fn_registrar_auditoria(p_usuario_auditoria, 'SEGURIDAD', 'EDITAR', 'Rol ID: ' || p_id);
    UPDATE public.roles 
    SET nombre = COALESCE(p_nombre, nombre), descripcion = COALESCE(p_descripcion, descripcion),
        auditoria_id = v_auditoria_id, fechaa = NOW()
    WHERE id = p_id;
    RETURN FOUND;
END;
$$ LANGUAGE plpgsql;

-- 4. ELIMINAR ROL
CREATE OR REPLACE FUNCTION fn_eliminar_rol(
    p_id INTEGER,
    p_usuario_auditoria VARCHAR
) RETURNS BOOLEAN AS $$
DECLARE
    v_auditoria_id VARCHAR;
BEGIN
    v_auditoria_id := fn_registrar_auditoria(p_usuario_auditoria, 'SEGURIDAD', 'ELIMINAR', 'Rol ID: ' || p_id);
    UPDATE public.roles SET estadoa = false, auditoria_id = v_auditoria_id, fechaa = NOW()
    WHERE id = p_id;
    RETURN FOUND;
END;
$$ LANGUAGE plpgsql;


-- 1. CREAR USUARIO
CREATE OR REPLACE FUNCTION fn_crear_usuario(
    p_empleado_id VARCHAR,
    p_username VARCHAR,
    p_password_hash VARCHAR, -- Supabase Auth lo maneja aparte, pero si usas tu tabla:
    p_rol_id INTEGER,
    p_usuario_auditoria VARCHAR
) RETURNS INTEGER AS $$
DECLARE
    v_id INTEGER;
    v_auditoria_id VARCHAR;
BEGIN
    -- Validar username único
    IF EXISTS (SELECT 1 FROM public.usuarios WHERE username = p_username) THEN
        RAISE EXCEPTION 'El usuario % ya existe.', p_username;
    END IF;

    v_auditoria_id := fn_registrar_auditoria(p_usuario_auditoria, 'SEGURIDAD', 'CREAR', 'Usuario: ' || p_username);

    INSERT INTO public.usuarios (empleado_id, username, password_hash, rol_id, estado, auditoria_id)
    VALUES (p_empleado_id, p_username, p_password_hash, p_rol_id, 'ACTIVO', v_auditoria_id)
    RETURNING id INTO v_id;
    
    -- Vincular empleado con usuario
    UPDATE public.empleados SET usuario_id = v_id WHERE id = p_empleado_id;

    RETURN v_id;
END;
$$ LANGUAGE plpgsql;

-- 2. LEER USUARIOS
CREATE OR REPLACE FUNCTION fn_leer_usuarios(
    p_buscar TEXT DEFAULT NULL
) RETURNS TABLE (
    id INTEGER, username VARCHAR, empleado TEXT, rol VARCHAR, estado VARCHAR
) AS $$
BEGIN
    RETURN QUERY 
    SELECT 
        u.id, 
        u.username, 
        (e.nombres || ' ' || e.apellido_paterno)::TEXT,
        r.nombre as rol,
        u.estado
    FROM public.usuarios u
    JOIN public.empleados e ON u.empleado_id = e.id
    JOIN public.roles r ON u.rol_id = r.id
    WHERE u.estadoa = true
    AND (p_buscar IS NULL OR u.username ILIKE '%' || p_buscar || '%');
END;
$$ LANGUAGE plpgsql;

-- 3. ACTUALIZAR USUARIO (Cambio de rol o contraseña)
CREATE OR REPLACE FUNCTION fn_actualizar_usuario(
    p_id INTEGER,
    p_rol_id INTEGER,
    p_password_hash VARCHAR, -- Enviar NULL si no se cambia
    p_usuario_auditoria VARCHAR
) RETURNS BOOLEAN AS $$
DECLARE
    v_auditoria_id VARCHAR;
BEGIN
    v_auditoria_id := fn_registrar_auditoria(p_usuario_auditoria, 'SEGURIDAD', 'EDITAR', 'Usuario ID: ' || p_id);

    UPDATE public.usuarios
    SET rol_id = COALESCE(p_rol_id, rol_id),
        password_hash = COALESCE(p_password_hash, password_hash),
        auditoria_id = v_auditoria_id,
        fechaa = NOW()
    WHERE id = p_id;
    RETURN FOUND;
END;
$$ LANGUAGE plpgsql;

-- 4. ELIMINAR USUARIO (Lógico)
CREATE OR REPLACE FUNCTION fn_eliminar_usuario(
    p_id INTEGER,
    p_usuario_auditoria VARCHAR
) RETURNS BOOLEAN AS $$
DECLARE
    v_auditoria_id VARCHAR;
BEGIN
    v_auditoria_id := fn_registrar_auditoria(p_usuario_auditoria, 'SEGURIDAD', 'ELIMINAR', 'Usuario ID: ' || p_id);
    UPDATE public.usuarios SET estado = 'INACTIVO', estadoa = false, auditoria_id = v_auditoria_id, fechaa = NOW()
    WHERE id = p_id;
    RETURN FOUND;
END;
$$ LANGUAGE plpgsql;


-- 1. CREAR CATEGORÍA
CREATE OR REPLACE FUNCTION fn_crear_categoria(
    p_nombre VARCHAR,
    p_descripcion TEXT,
    p_usuario_auditoria VARCHAR
) RETURNS INTEGER AS $$
DECLARE
    v_id INTEGER;
    v_auditoria_id VARCHAR;
BEGIN
    -- Crear registro de auditoría
    v_auditoria_id := fn_registrar_auditoria(p_usuario_auditoria, 'CATEGORIAS', 'CREAR', 'Nueva categoría: ' || p_nombre);

    -- Insertar categoría
    INSERT INTO public.categorias (nombre, descripcion, activo, auditoria_id)
    VALUES (p_nombre, p_descripcion, true, v_auditoria_id)
    RETURNING id INTO v_id;

    RETURN v_id;
END;
$$ LANGUAGE plpgsql;

-- 2. LEER CATEGORÍAS (Ver lista)
CREATE OR REPLACE FUNCTION fn_leer_categorias()
RETURNS TABLE (
    id INTEGER,
    nombre VARCHAR,
    descripcion TEXT,
    activo BOOLEAN
) AS $$
BEGIN
    RETURN QUERY 
    SELECT c.id, c.nombre, c.descripcion, c.activo
    FROM public.categorias c
    WHERE c.estadoa = true -- Solo registros no eliminados
    ORDER BY c.nombre ASC;
END;
$$ LANGUAGE plpgsql;

-- 3. ACTUALIZAR CATEGORÍA
CREATE OR REPLACE FUNCTION fn_actualizar_categoria(
    p_id INTEGER,
    p_nombre VARCHAR,
    p_descripcion TEXT,
    p_usuario_auditoria VARCHAR
) RETURNS BOOLEAN AS $$
DECLARE
    v_auditoria_id VARCHAR;
BEGIN
    v_auditoria_id := fn_registrar_auditoria(p_usuario_auditoria, 'CATEGORIAS', 'EDITAR', 'ID: ' || p_id);

    UPDATE public.categorias
    SET 
        nombre = COALESCE(p_nombre, nombre),
        descripcion = COALESCE(p_descripcion, descripcion),
        auditoria_id = v_auditoria_id,
        fechaa = NOW()
    WHERE id = p_id;

    RETURN FOUND;
END;
$$ LANGUAGE plpgsql;

-- 4. ELIMINAR CATEGORÍA (Lógico)
CREATE OR REPLACE FUNCTION fn_eliminar_categoria(
    p_id INTEGER,
    p_usuario_auditoria VARCHAR
) RETURNS BOOLEAN AS $$
DECLARE
    v_auditoria_id VARCHAR;
BEGIN
    -- Validación: No borrar si tiene productos activos asociados
    IF EXISTS (SELECT 1 FROM public.productos WHERE categoria_id = p_id AND estadoa = true) THEN
        RAISE EXCEPTION 'No se puede eliminar la categoría porque tiene productos asociados.';
    END IF;

    v_auditoria_id := fn_registrar_auditoria(p_usuario_auditoria, 'CATEGORIAS', 'ELIMINAR', 'ID: ' || p_id);

    -- Soft delete (borrado lógico)
    UPDATE public.categorias
    SET activo = false, estadoa = false, auditoria_id = v_auditoria_id, fechaa = NOW()
    WHERE id = p_id;

    RETURN FOUND;
END;
$$ LANGUAGE plpgsql;


-- 1. CREAR PROVEEDOR
CREATE OR REPLACE FUNCTION fn_crear_proveedor(
    p_razon_social VARCHAR,
    p_nit_ci VARCHAR,
    p_telefono VARCHAR,
    p_celular VARCHAR,
    p_email VARCHAR,
    p_direccion TEXT,
    p_nombre_contacto VARCHAR,
    p_plazo_credito INTEGER,
    p_usuario_auditoria VARCHAR
) RETURNS VARCHAR AS $$
DECLARE
    v_id VARCHAR;
    v_auditoria_id VARCHAR;
BEGIN
    -- Validar duplicados (NIT/CI debe ser único)
    IF EXISTS (SELECT 1 FROM public.proveedores WHERE nit_ci = p_nit_ci AND estadoa = true) THEN
        RAISE EXCEPTION 'El proveedor con NIT/CI % ya existe.', p_nit_ci;
    END IF;

    v_auditoria_id := fn_registrar_auditoria(p_usuario_auditoria, 'PROVEEDORES', 'CREAR', 'Proveedor: ' || p_razon_social);
    v_id := gen_random_uuid()::text;

    INSERT INTO public.proveedores (
        id, razon_social, nit_ci, telefono, celular_contacto, email, 
        direccion, nombre_contacto, plazo_credito, estado, auditoria_id
    ) VALUES (
        v_id, p_razon_social, p_nit_ci, p_telefono, p_celular, p_email, 
        p_direccion, p_nombre_contacto, p_plazo_credito, 'ACTIVO', v_auditoria_id
    );

    RETURN v_id;
END;
$$ LANGUAGE plpgsql;

-- 2. LEER PROVEEDORES (Con buscador)
CREATE OR REPLACE FUNCTION fn_leer_proveedores(
    p_buscar_texto TEXT DEFAULT NULL
) RETURNS TABLE (
    id VARCHAR,
    razon_social VARCHAR,
    nit_ci VARCHAR,
    contacto VARCHAR,
    telefono VARCHAR,
    email VARCHAR,
    estado VARCHAR
) AS $$
BEGIN
    RETURN QUERY 
    SELECT 
        p.id, 
        p.razon_social, 
        p.nit_ci, 
        p.nombre_contacto, 
        COALESCE(p.telefono, p.celular_contacto) as telefono,
        p.email,
        p.estado
    FROM public.proveedores p
    WHERE 
        p.estadoa = true
        AND (p_buscar_texto IS NULL OR 
             p.razon_social ILIKE '%' || p_buscar_texto || '%' OR 
             p.nit_ci ILIKE '%' || p_buscar_texto || '%');
END;
$$ LANGUAGE plpgsql;

-- 3. ACTUALIZAR PROVEEDOR
CREATE OR REPLACE FUNCTION fn_actualizar_proveedor(
    p_id VARCHAR,
    p_telefono VARCHAR,
    p_celular VARCHAR,
    p_email VARCHAR,
    p_direccion TEXT,
    p_nombre_contacto VARCHAR,
    p_plazo_credito INTEGER,
    p_usuario_auditoria VARCHAR
) RETURNS BOOLEAN AS $$
DECLARE
    v_auditoria_id VARCHAR;
BEGIN
    v_auditoria_id := fn_registrar_auditoria(p_usuario_auditoria, 'PROVEEDORES', 'EDITAR', 'ID: ' || p_id);

    UPDATE public.proveedores
    SET 
        telefono = COALESCE(p_telefono, telefono),
        celular_contacto = COALESCE(p_celular, celular_contacto),
        email = COALESCE(p_email, email),
        direccion = COALESCE(p_direccion, direccion),
        nombre_contacto = COALESCE(p_nombre_contacto, nombre_contacto),
        plazo_credito = COALESCE(p_plazo_credito, plazo_credito),
        auditoria_id = v_auditoria_id,
        fechaa = NOW()
    WHERE id = p_id;

    RETURN FOUND;
END;
$$ LANGUAGE plpgsql;

-- 4. ELIMINAR PROVEEDOR (Lógico)
CREATE OR REPLACE FUNCTION fn_eliminar_proveedor(
    p_id VARCHAR,
    p_usuario_auditoria VARCHAR
) RETURNS BOOLEAN AS $$
DECLARE
    v_auditoria_id VARCHAR;
BEGIN
    v_auditoria_id := fn_registrar_auditoria(p_usuario_auditoria, 'PROVEEDORES', 'ELIMINAR', 'ID: ' || p_id);

    -- Cambiamos estado a INACTIVO y estadoa a false
    UPDATE public.proveedores
    SET 
        estado = 'INACTIVO',
        estadoa = false,
        auditoria_id = v_auditoria_id,
        fechaa = NOW()
    WHERE id = p_id;

    RETURN FOUND;
END;
$$ LANGUAGE plpgsql;


-- 1. CREAR PRODUCTO (PROD-01)
CREATE OR REPLACE FUNCTION fn_crear_producto(
    p_codigo_interno VARCHAR,
    p_codigo_barras VARCHAR,
    p_nombre VARCHAR,
    p_categoria_id INTEGER,
    p_marca VARCHAR,
    p_proveedor_id VARCHAR, -- Proveedor principal
    p_precio_costo NUMERIC,
    p_precio_venta NUMERIC,
    p_stock_minimo INTEGER,
    p_stock_maximo INTEGER,
    p_unidad_medida VARCHAR,
    p_presentacion VARCHAR,
    p_controla_vencimiento BOOLEAN,
    p_usuario_auditoria VARCHAR
) RETURNS VARCHAR AS $$
DECLARE
    v_id VARCHAR;
    v_auditoria_id VARCHAR;
BEGIN
    -- Validar código interno único
    IF EXISTS (SELECT 1 FROM public.productos WHERE codigo_interno = p_codigo_interno) THEN
        RAISE EXCEPTION 'El código interno % ya existe.', p_codigo_interno;
    END IF;

    -- Validar existencia de categoría
    IF NOT EXISTS (SELECT 1 FROM public.categorias WHERE id = p_categoria_id AND activo = true) THEN
        RAISE EXCEPTION 'La categoría seleccionada no existe o está inactiva.';
    END IF;

    v_auditoria_id := fn_registrar_auditoria(p_usuario_auditoria, 'PRODUCTOS', 'CREAR', 'Producto: ' || p_nombre);
    v_id := gen_random_uuid()::text;

    INSERT INTO public.productos (
        id, codigo_interno, codigo_barras, nombre, categoria_id, marca, 
        proveedor_principal_id, precio_costo, precio_venta, 
        stock_minimo, stock_maximo, stock_actual, 
        unidad_medida, presentacion, controla_vencimiento, 
        auditoria_id
    ) VALUES (
        v_id, p_codigo_interno, p_codigo_barras, p_nombre, p_categoria_id, p_marca,
        p_proveedor_id, p_precio_costo, p_precio_venta,
        p_stock_minimo, p_stock_maximo, 0, -- Stock inicial siempre 0
        p_unidad_medida, p_presentacion, p_controla_vencimiento,
        v_auditoria_id
    );

    RETURN v_id;
END;
$$ LANGUAGE plpgsql;

-- 2. LEER PRODUCTOS (PROD-01 / Búsqueda General)
-- Incluye lógica para mostrar el estado del stock visualmente (Semáforo)
CREATE OR REPLACE FUNCTION fn_leer_productos(
    p_buscar TEXT DEFAULT NULL,
    p_categoria_id INTEGER DEFAULT NULL
) RETURNS TABLE (
    id VARCHAR,
    codigo_interno VARCHAR,
    codigo_barras VARCHAR,
    nombre VARCHAR,
    categoria VARCHAR,
    marca VARCHAR,
    precio_venta NUMERIC,
    stock_actual INTEGER,
    stock_minimo INTEGER,
    estado_stock TEXT -- 'CRITICO', 'BAJO', 'NORMAL', 'SOBRESTOCK'
) AS $$
BEGIN
    RETURN QUERY 
    SELECT 
        p.id, 
        p.codigo_interno, 
        p.codigo_barras,
        p.nombre, 
        c.nombre as categoria,
        p.marca,
        p.precio_venta, 
        p.stock_actual,
        p.stock_minimo,
        CASE 
            WHEN p.stock_actual <= 0 THEN 'CRITICO'
            WHEN p.stock_actual <= p.stock_minimo THEN 'BAJO'
            WHEN p.stock_actual >= p.stock_maximo AND p.stock_maximo > 0 THEN 'SOBRESTOCK'
            ELSE 'NORMAL'
        END as estado_stock
    FROM public.productos p
    LEFT JOIN public.categorias c ON p.categoria_id = c.id
    WHERE 
        p.estadoa = true
        AND (p_categoria_id IS NULL OR p.categoria_id = p_categoria_id)
        AND (p_buscar IS NULL OR 
             p.nombre ILIKE '%' || p_buscar || '%' OR 
             p.codigo_interno ILIKE '%' || p_buscar || '%' OR
             p.codigo_barras ILIKE '%' || p_buscar || '%');
END;
$$ LANGUAGE plpgsql;

-- 3. LEER UN SOLO PRODUCTO (Para cargar el formulario de edición)
CREATE OR REPLACE FUNCTION fn_obtener_producto_por_id(
    p_id VARCHAR
) RETURNS TABLE (
    id VARCHAR,
    codigo_interno VARCHAR,
    codigo_barras VARCHAR,
    nombre VARCHAR,
    categoria_id INTEGER,
    marca VARCHAR,
    proveedor_id VARCHAR,
    precio_costo NUMERIC,
    precio_venta NUMERIC,
    stock_minimo INTEGER,
    stock_maximo INTEGER,
    unidad_medida VARCHAR,
    presentacion VARCHAR,
    controla_vencimiento BOOLEAN
) AS $$
BEGIN
    RETURN QUERY 
    SELECT 
        p.id, p.codigo_interno, p.codigo_barras, p.nombre, p.categoria_id, p.marca,
        p.proveedor_principal_id, p.precio_costo, p.precio_venta,
        p.stock_minimo, p.stock_maximo, p.unidad_medida, p.presentacion,
        p.controla_vencimiento
    FROM public.productos p
    WHERE p.id = p_id;
END;
$$ LANGUAGE plpgsql;

-- 4. ACTUALIZAR PRODUCTO (PROD-02)
CREATE OR REPLACE FUNCTION fn_actualizar_producto(
    p_id VARCHAR,
    p_codigo_barras VARCHAR,
    p_nombre VARCHAR,
    p_categoria_id INTEGER,
    p_marca VARCHAR,
    p_proveedor_id VARCHAR,
    p_precio_costo NUMERIC,
    p_precio_venta NUMERIC,
    p_stock_minimo INTEGER,
    p_stock_maximo INTEGER,
    p_usuario_auditoria VARCHAR
) RETURNS BOOLEAN AS $$
DECLARE
    v_auditoria_id VARCHAR;
BEGIN
    v_auditoria_id := fn_registrar_auditoria(p_usuario_auditoria, 'PRODUCTOS', 'EDITAR', 'ID: ' || p_id);

    UPDATE public.productos
    SET 
        codigo_barras = COALESCE(p_codigo_barras, codigo_barras),
        nombre = COALESCE(p_nombre, nombre),
        categoria_id = COALESCE(p_categoria_id, categoria_id),
        marca = COALESCE(p_marca, marca),
        proveedor_principal_id = COALESCE(p_proveedor_id, proveedor_principal_id),
        precio_costo = COALESCE(p_precio_costo, precio_costo),
        precio_venta = COALESCE(p_precio_venta, precio_venta),
        stock_minimo = COALESCE(p_stock_minimo, stock_minimo),
        stock_maximo = COALESCE(p_stock_maximo, stock_maximo),
        auditoria_id = v_auditoria_id,
        fechaa = NOW()
    WHERE id = p_id;

    RETURN FOUND;
END;
$$ LANGUAGE plpgsql;

-- 5. ELIMINAR PRODUCTO (PROD-03 - Eliminación Lógica)
CREATE OR REPLACE FUNCTION fn_eliminar_producto(
    p_id VARCHAR,
    p_motivo VARCHAR,
    p_usuario_auditoria VARCHAR
) RETURNS BOOLEAN AS $$
DECLARE
    v_auditoria_id VARCHAR;
    v_stock_actual INTEGER;
BEGIN
    -- Validación: Verificar stock antes de eliminar (Regla de negocio segura)
    SELECT stock_actual INTO v_stock_actual FROM public.productos WHERE id = p_id;
    
    IF v_stock_actual > 0 THEN
        RAISE EXCEPTION 'No se puede eliminar el producto porque tiene stock (% unidades). Realice un ajuste de salida primero.', v_stock_actual;
    END IF;

    v_auditoria_id := fn_registrar_auditoria(p_usuario_auditoria, 'PRODUCTOS', 'ELIMINAR', 'ID: ' || p_id || ' Motivo: ' || p_motivo);

    UPDATE public.productos
    SET 
        estadoa = false, 
        motivo_desactivacion = p_motivo,
        auditoria_id = v_auditoria_id,
        fechaa = NOW()
    WHERE id = p_id;

    RETURN FOUND;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION fn_registrar_movimiento_stock(
    p_producto_id VARCHAR,
    p_tipo VARCHAR, -- 'ENTRADA', 'SALIDA', 'AJUSTE+', 'VENTA', etc.
    p_cantidad NUMERIC,
    p_lote VARCHAR,
    p_fecha_vencimiento DATE,
    p_documento_referencia VARCHAR,
    p_motivo VARCHAR,
    p_usuario_id INTEGER,
    p_auditoria_id VARCHAR
) RETURNS VOID AS $$
DECLARE
    v_stock_actual INTEGER;
BEGIN
    -- 1. Actualizar Stock en la tabla PRODUCTOS
    IF p_tipo IN ('ENTRADA', 'AJUSTE+', 'DEVOLUCION_VENTA') THEN
        UPDATE public.productos 
        SET stock_actual = stock_actual + p_cantidad 
        WHERE id = p_producto_id;
    ELSIF p_tipo IN ('SALIDA', 'AJUSTE-', 'VENTA', 'MERMA', 'DAÑO', 'ROBO', 'DEVOLUCION_PROVEEDOR') THEN
        -- Validación: No dejar stock negativo
        SELECT stock_actual INTO v_stock_actual FROM public.productos WHERE id = p_producto_id;
        
        IF (v_stock_actual - p_cantidad) < 0 THEN
             RAISE EXCEPTION 'Stock insuficiente (Actual: %) para realizar salida de %.', v_stock_actual, p_cantidad;
        END IF;
        
        UPDATE public.productos 
        SET stock_actual = stock_actual - p_cantidad 
        WHERE id = p_producto_id;
    END IF;

    -- 2. Registrar en el Historial (KARDEX)
    INSERT INTO public.movimientos_inventario (
        id, producto_id, tipo, cantidad, lote, fecha_vencimiento, 
        documento, motivo, usuario_id, auditoria_id
    ) VALUES (
        gen_random_uuid()::text, p_producto_id, p_tipo, p_cantidad, p_lote, p_fecha_vencimiento, 
        p_documento_referencia, p_motivo, p_usuario_id, p_auditoria_id
    );
END;
$$ LANGUAGE plpgsql;


-- 1. CREAR ORDEN DE COMPRA (COMP-02)
-- JSON Esperado: [{"producto_id": "uuid", "cantidad": 10, "precio": 50.5}, ...]
CREATE OR REPLACE FUNCTION fn_crear_orden_compra(
    p_proveedor_id VARCHAR,
    p_fecha_entrega DATE,
    p_detalles_json JSONB,
    p_usuario_id INTEGER,
    p_usuario_nombre VARCHAR
) RETURNS VARCHAR AS $$
DECLARE
    v_orden_id VARCHAR;
    v_auditoria_id VARCHAR;
    v_total NUMERIC := 0;
    rec RECORD;
BEGIN
    v_auditoria_id := fn_registrar_auditoria(p_usuario_nombre, 'COMPRAS', 'CREAR_ORDEN', 'Prov: ' || p_proveedor_id);
    v_orden_id := gen_random_uuid()::text;

    -- Cabecera
    INSERT INTO public.ordenes_compra (
        id, proveedor_id, fecha_emision, fecha_entrega, estado, total, usuario_id, auditoria_id
    ) VALUES (
        v_orden_id, p_proveedor_id, CURRENT_DATE, p_fecha_entrega, 'PENDIENTE', 0, p_usuario_id, v_auditoria_id
    );

    -- Detalles
    FOR rec IN SELECT * FROM jsonb_to_recordset(p_detalles_json) AS x(producto_id VARCHAR, cantidad INT, precio NUMERIC)
    LOOP
        INSERT INTO public.detalle_orden_compra (
            orden_id, producto_id, cantidad, precio_unitario, subtotal, auditoria_id
        ) VALUES (
            v_orden_id, rec.producto_id, rec.cantidad, rec.precio, (rec.cantidad * rec.precio), v_auditoria_id
        );
        v_total := v_total + (rec.cantidad * rec.precio);
    END LOOP;

    -- Actualizar total
    UPDATE public.ordenes_compra SET total = v_total WHERE id = v_orden_id;

    RETURN v_orden_id;
END;
$$ LANGUAGE plpgsql;

-- 2. LEER ÓRDENES (Historial COMP-05)
CREATE OR REPLACE FUNCTION fn_leer_ordenes_compra(
    p_estado VARCHAR DEFAULT NULL,
    p_fecha_inicio DATE DEFAULT NULL,
    p_fecha_fin DATE DEFAULT NULL
) RETURNS TABLE (
    id VARCHAR,
    fecha DATE,
    proveedor VARCHAR,
    total NUMERIC,
    estado VARCHAR
) AS $$
BEGIN
    RETURN QUERY 
    SELECT oc.id, oc.fecha_emision, p.razon_social, oc.total, oc.estado
    FROM public.ordenes_compra oc
    JOIN public.proveedores p ON oc.proveedor_id = p.id
    WHERE oc.estadoa = true
    AND (p_estado IS NULL OR oc.estado = p_estado)
    AND (p_fecha_inicio IS NULL OR oc.fecha_emision >= p_fecha_inicio)
    AND (p_fecha_fin IS NULL OR oc.fecha_emision <= p_fecha_fin)
    ORDER BY oc.fecha_emision DESC;
END;
$$ LANGUAGE plpgsql;

-- 3. LEER DETALLE DE UNA ORDEN
CREATE OR REPLACE FUNCTION fn_leer_detalle_orden(
    p_orden_id VARCHAR
) RETURNS TABLE (
    producto VARCHAR, cantidad INTEGER, precio NUMERIC, subtotal NUMERIC
) AS $$
BEGIN
    RETURN QUERY 
    SELECT p.nombre, d.cantidad, d.precio_unitario, d.subtotal
    FROM public.detalle_orden_compra d
    JOIN public.productos p ON d.producto_id = p.id
    WHERE d.orden_id = p_orden_id AND d.estadoa = true;
END;
$$ LANGUAGE plpgsql;

-- 4. ANULAR/CANCELAR ORDEN (DELETE Lógico)
-- Solo permitido si la orden sigue PENDIENTE.
CREATE OR REPLACE FUNCTION fn_anular_orden_compra(
    p_orden_id VARCHAR,
    p_motivo VARCHAR,
    p_usuario_auditoria VARCHAR
) RETURNS BOOLEAN AS $$
DECLARE
    v_estado_actual VARCHAR;
    v_auditoria_id VARCHAR;
BEGIN
    SELECT estado INTO v_estado_actual FROM public.ordenes_compra WHERE id = p_orden_id;

    IF v_estado_actual <> 'PENDIENTE' THEN
        RAISE EXCEPTION 'No se puede anular una orden que ya fue procesada (%s).', v_estado_actual;
    END IF;

    v_auditoria_id := fn_registrar_auditoria(p_usuario_auditoria, 'COMPRAS', 'ANULAR', 'Orden: ' || p_orden_id || ' Motivo: ' || p_motivo);

    UPDATE public.ordenes_compra 
    SET estado = 'CANCELADA', auditoria_id = v_auditoria_id, fechaa = NOW() 
    WHERE id = p_orden_id;

    RETURN FOUND;
END;
$$ LANGUAGE plpgsql;


-- RECEPCIONAR MERCADERÍA
CREATE OR REPLACE FUNCTION fn_recepcionar_orden(
    p_orden_id VARCHAR,
    p_lote VARCHAR,
    p_fecha_vencimiento DATE,
    p_nro_factura_prov VARCHAR,
    p_usuario_id INTEGER,
    p_usuario_nombre VARCHAR
) RETURNS VARCHAR AS $$
DECLARE
    v_recepcion_id VARCHAR;
    v_auditoria_id VARCHAR;
    v_proveedor_id VARCHAR;
    v_total_orden NUMERIC;
    rec RECORD;
BEGIN
    -- Validar
    SELECT total, proveedor_id INTO v_total_orden, v_proveedor_id 
    FROM public.ordenes_compra WHERE id = p_orden_id AND estado = 'PENDIENTE';

    IF NOT FOUND THEN
        RAISE EXCEPTION 'Orden no encontrada o ya fue procesada.';
    END IF;

    v_auditoria_id := fn_registrar_auditoria(p_usuario_nombre, 'COMPRAS', 'RECEPCION', 'Orden ID: ' || p_orden_id);
    v_recepcion_id := gen_random_uuid()::text;

    -- 1. Crear Recepción
    INSERT INTO public.recepciones (
        id, orden_id, fecha_ingreso, lote, fecha_vencimiento, usuario_id, auditoria_id
    ) VALUES (
        v_recepcion_id, p_orden_id, CURRENT_DATE, p_lote, p_fecha_vencimiento, p_usuario_id, v_auditoria_id
    );

    -- 2. Aumentar Stock (Loop)
    FOR rec IN SELECT producto_id, cantidad FROM public.detalle_orden_compra WHERE orden_id = p_orden_id
    LOOP
        PERFORM fn_registrar_movimiento_stock(
            rec.producto_id,
            'ENTRADA',
            rec.cantidad,
            p_lote,
            p_fecha_vencimiento,
            'Rec ' || v_recepcion_id,
            'Ingreso Mercadería',
            p_usuario_id,
            v_auditoria_id
        );
        
        -- Opcional: Registrar Lote específico si usas tabla lotes
        INSERT INTO public.lotes (id, producto_id, lote, fecha_vencimiento, cantidad, auditoria_id)
        VALUES (gen_random_uuid()::text, rec.producto_id, p_lote, p_fecha_vencimiento, rec.cantidad, v_auditoria_id);
    END LOOP;

    -- 3. Generar Deuda (Cuentas por Pagar)
    INSERT INTO public.cuentas_por_pagar (
        id, proveedor_id, factura_nro, fecha_emision, fecha_vencimiento, 
        monto_total, saldo_pendiente, estado, auditoria_id
    ) VALUES (
        gen_random_uuid()::text, v_proveedor_id, p_nro_factura_prov, CURRENT_DATE, 
        CURRENT_DATE + 30, -- Default 30 días
        v_total_orden, v_total_orden, 'PENDIENTE', v_auditoria_id
    );

    -- 4. Cerrar Orden
    UPDATE public.ordenes_compra SET estado = 'RECIBIDA' WHERE id = p_orden_id;

    RETURN v_recepcion_id;
END;
$$ LANGUAGE plpgsql;


-- 1. CREAR DEVOLUCIÓN (Resta Stock)
CREATE OR REPLACE FUNCTION fn_devolver_proveedor(
    p_recepcion_id VARCHAR,
    p_motivo VARCHAR, -- 'DAÑO', 'VENCIDO'
    p_producto_id VARCHAR,
    p_cantidad INTEGER,
    p_observaciones TEXT,
    p_usuario_id INTEGER,
    p_usuario_nombre VARCHAR
) RETURNS VARCHAR AS $$
DECLARE
    v_devolucion_id VARCHAR;
    v_auditoria_id VARCHAR;
BEGIN
    v_auditoria_id := fn_registrar_auditoria(p_usuario_nombre, 'COMPRAS', 'DEVOLUCION', 'Recepcion: ' || p_recepcion_id);
    v_devolucion_id := gen_random_uuid()::text;

    -- Crear cabecera devolución
    INSERT INTO public.devoluciones_proveedor (
        id, recepcion_id, motivo, cantidad, observaciones, auditoria_id
    ) VALUES (
        v_devolucion_id, p_recepcion_id, p_motivo, p_cantidad, p_observaciones, v_auditoria_id
    );

    -- Crear detalle devolución
    INSERT INTO public.detalle_devolucion_proveedor (
        devolucion_id, producto_id, cantidad, auditoria_id
    ) VALUES (
        v_devolucion_id, p_producto_id, p_cantidad, v_auditoria_id
    );

    -- RESTAR STOCK
    PERFORM fn_registrar_movimiento_stock(
        p_producto_id,
        'DEVOLUCION_PROVEEDOR', -- Tipo especial que resta
        p_cantidad,
        NULL,
        NULL,
        'Dev ' || v_devolucion_id,
        p_motivo,
        p_usuario_id,
        v_auditoria_id
    );

    RETURN v_devolucion_id;
END;
$$ LANGUAGE plpgsql;

-- 2. LEER DEVOLUCIONES
CREATE OR REPLACE FUNCTION fn_leer_devoluciones_proveedor()
RETURNS TABLE (
    id VARCHAR, fecha TIMESTAMP, motivo VARCHAR, cantidad INTEGER, producto VARCHAR
) AS $$
BEGIN
    RETURN QUERY
    SELECT d.id, d.fecha, d.motivo, d.cantidad, p.nombre
    FROM public.devoluciones_proveedor d
    JOIN public.detalle_devolucion_proveedor dd ON d.id = dd.devolucion_id
    JOIN public.productos p ON dd.producto_id = p.id
    WHERE d.estadoa = true
    ORDER BY d.fecha DESC;
END;
$$ LANGUAGE plpgsql;

-- 3. CANCELAR DEVOLUCIÓN (Complejo: Debería devolver el stock, por seguridad solo anulamos lógico)
CREATE OR REPLACE FUNCTION fn_anular_devolucion_proveedor(
    p_devolucion_id VARCHAR,
    p_usuario_auditoria VARCHAR
) RETURNS BOOLEAN AS $$
DECLARE
    v_auditoria_id VARCHAR;
BEGIN
    -- Nota: Idealmente deberías re-ingresar el stock aquí, pero simplificamos a baja lógica por ahora.
    v_auditoria_id := fn_registrar_auditoria(p_usuario_auditoria, 'COMPRAS', 'ANULAR_DEVOLUCION', 'ID: ' || p_devolucion_id);

    UPDATE public.devoluciones_proveedor 
    SET estadoa = false, auditoria_id = v_auditoria_id 
    WHERE id = p_devolucion_id;

    RETURN FOUND;
END;
$$ LANGUAGE plpgsql;


-- 1. CREAR CLIENTE (CLI-01)
CREATE OR REPLACE FUNCTION fn_crear_cliente(
    p_nombres VARCHAR,
    p_apellidos_pat VARCHAR,
    p_ci_nit VARCHAR,
    p_telefono VARCHAR,
    p_email VARCHAR,
    p_direccion TEXT,
    p_usuario_auditoria VARCHAR
) RETURNS VARCHAR AS $$
DECLARE
    v_id VARCHAR;
    v_auditoria_id VARCHAR;
BEGIN
    -- Validar CI/NIT único
    IF EXISTS (SELECT 1 FROM public.clientes WHERE ci_nit = p_ci_nit AND estadoa = true) THEN
        RAISE EXCEPTION 'El cliente con CI/NIT % ya existe.', p_ci_nit;
    END IF;

    v_auditoria_id := fn_registrar_auditoria(p_usuario_auditoria, 'CLIENTES', 'CREAR', 'Cliente: ' || p_nombres);
    v_id := gen_random_uuid()::text;

    INSERT INTO public.clientes (
        id, nombres, apellido_paterno, ci_nit, telefono, email, direccion, estado, auditoria_id
    ) VALUES (
        v_id, p_nombres, p_apellidos_pat, p_ci_nit, p_telefono, p_email, p_direccion, 'ACTIVO', v_auditoria_id
    );

    RETURN v_id;
END;
$$ LANGUAGE plpgsql;

-- 2. LEER CLIENTES (CLI-03 - Buscador)
CREATE OR REPLACE FUNCTION fn_leer_clientes(
    p_buscar TEXT DEFAULT NULL
) RETURNS TABLE (
    id VARCHAR,
    nombre_completo TEXT,
    ci_nit VARCHAR,
    telefono VARCHAR,
    email VARCHAR
) AS $$
BEGIN
    RETURN QUERY 
    SELECT 
        c.id, 
        (c.nombres || ' ' || c.apellido_paterno)::TEXT,
        c.ci_nit, 
        c.telefono,
        c.email
    FROM public.clientes c
    WHERE c.estadoa = true
    AND (p_buscar IS NULL OR 
         c.ci_nit ILIKE '%' || p_buscar || '%' OR 
         c.nombres ILIKE '%' || p_buscar || '%');
END;
$$ LANGUAGE plpgsql;

-- 3. ACTUALIZAR CLIENTE (CLI-02)
CREATE OR REPLACE FUNCTION fn_actualizar_cliente(
    p_id VARCHAR,
    p_telefono VARCHAR,
    p_email VARCHAR,
    p_direccion TEXT,
    p_usuario_auditoria VARCHAR
) RETURNS BOOLEAN AS $$
DECLARE
    v_auditoria_id VARCHAR;
BEGIN
    v_auditoria_id := fn_registrar_auditoria(p_usuario_auditoria, 'CLIENTES', 'EDITAR', 'ID: ' || p_id);

    UPDATE public.clientes
    SET 
        telefono = COALESCE(p_telefono, telefono),
        email = COALESCE(p_email, email),
        direccion = COALESCE(p_direccion, direccion),
        auditoria_id = v_auditoria_id,
        fechaa = NOW()
    WHERE id = p_id;

    RETURN FOUND;
END;
$$ LANGUAGE plpgsql;

-- 4. ELIMINAR CLIENTE (CLI-06 - Lógico)
CREATE OR REPLACE FUNCTION fn_eliminar_cliente(
    p_id VARCHAR,
    p_usuario_auditoria VARCHAR
) RETURNS BOOLEAN AS $$
DECLARE
    v_auditoria_id VARCHAR;
BEGIN
    v_auditoria_id := fn_registrar_auditoria(p_usuario_auditoria, 'CLIENTES', 'ELIMINAR', 'ID: ' || p_id);

    UPDATE public.clientes
    SET estado = 'INACTIVO', estadoa = false, auditoria_id = v_auditoria_id, fechaa = NOW()
    WHERE id = p_id;

    RETURN FOUND;
END;
$$ LANGUAGE plpgsql;

-- 1. CREAR VENTA (VENT-01 / VENT-02)
-- Input JSON: [{"producto_id": "uuid", "cantidad": 2, "precio": 10.5}, ...]
CREATE OR REPLACE FUNCTION fn_registrar_venta(
    p_cliente_id VARCHAR,
    p_tipo_comprobante VARCHAR,
    p_detalles_json JSONB,
    p_medio_pago VARCHAR, -- 'EFECTIVO', 'QR', etc.
    p_monto_total NUMERIC,
    p_monto_recibido NUMERIC,
    p_usuario_id INTEGER,
    p_usuario_nombre VARCHAR
) RETURNS VARCHAR AS $$
DECLARE
    v_venta_id VARCHAR;
    v_auditoria_id VARCHAR;
    v_vuelto NUMERIC;
    rec RECORD;
BEGIN
    -- Validar pago
    IF p_monto_recibido < p_monto_total THEN
        RAISE EXCEPTION 'El monto recibido es insuficiente.';
    END IF;

    v_vuelto := p_monto_recibido - p_monto_total;
    v_auditoria_id := fn_registrar_auditoria(p_usuario_nombre, 'VENTAS', 'NUEVA_VENTA', 'Total: ' || p_monto_total);
    v_venta_id := gen_random_uuid()::text;

    -- A. Insertar Cabecera
    INSERT INTO public.ventas (
        id, cliente_id, total, tipo_comprobante, usuario_id, auditoria_id, fecha_hora
    ) VALUES (
        v_venta_id, p_cliente_id, p_monto_total, p_tipo_comprobante, p_usuario_id, v_auditoria_id, NOW()
    );

    -- B. Procesar Detalles y RESTAR STOCK
    FOR rec IN SELECT * FROM jsonb_to_recordset(p_detalles_json) AS x(producto_id VARCHAR, cantidad INT, precio NUMERIC)
    LOOP
        -- Insertar detalle
        INSERT INTO public.detalle_ventas (
            venta_id, producto_id, cantidad, precio_unitario, subtotal, auditoria_id
        ) VALUES (
            v_venta_id, rec.producto_id, rec.cantidad, rec.precio, (rec.cantidad * rec.precio), v_auditoria_id
        );

        -- DESCONTAR STOCK (Llama a la función base del Módulo 4)
        PERFORM fn_registrar_movimiento_stock(
            rec.producto_id,
            'SALIDA', -- Tipo de movimiento
            rec.cantidad,
            NULL, NULL,
            'Venta ' || v_venta_id,
            'Salida por Venta',
            p_usuario_id,
            v_auditoria_id
        );
    END LOOP;

    -- C. Registrar Pago
    INSERT INTO public.pagos (
        id, venta_id, medio, importe, vuelto, auditoria_id
    ) VALUES (
        gen_random_uuid()::text, v_venta_id, p_medio_pago, p_monto_recibido, v_vuelto, v_auditoria_id
    );

    RETURN v_venta_id;
END;
$$ LANGUAGE plpgsql;

-- 2. LEER VENTAS (Historial)
CREATE OR REPLACE FUNCTION fn_leer_ventas(
    p_fecha_inicio DATE,
    p_fecha_fin DATE
) RETURNS TABLE (
    id VARCHAR,
    fecha TIMESTAMP,
    cliente TEXT,
    total NUMERIC,
    comprobante VARCHAR,
    estado BOOLEAN
) AS $$
BEGIN
    RETURN QUERY 
    SELECT 
        v.id, v.fecha_hora, (c.nombres || ' ' || c.apellido_paterno)::TEXT, 
        v.total, v.tipo_comprobante, v.estadoa
    FROM public.ventas v
    JOIN public.clientes c ON v.cliente_id = c.id
    WHERE v.fecha_hora::DATE BETWEEN p_fecha_inicio AND p_fecha_fin
    ORDER BY v.fecha_hora DESC;
END;
$$ LANGUAGE plpgsql;

-- 3. ACTUALIZAR VENTA (Limitado)
-- Solo permitimos cambiar el cliente (ej: error de facturación) para mantener integridad fiscal.
CREATE OR REPLACE FUNCTION fn_actualizar_venta_cliente(
    p_venta_id VARCHAR,
    p_nuevo_cliente_id VARCHAR,
    p_usuario_auditoria VARCHAR
) RETURNS BOOLEAN AS $$
DECLARE
    v_auditoria_id VARCHAR;
BEGIN
    v_auditoria_id := fn_registrar_auditoria(p_usuario_auditoria, 'VENTAS', 'EDITAR_CLIENTE', 'Venta ID: ' || p_venta_id);

    UPDATE public.ventas
    SET cliente_id = p_nuevo_cliente_id, auditoria_id = v_auditoria_id, fechaa = NOW()
    WHERE id = p_venta_id AND estadoa = true;

    RETURN FOUND;
END;
$$ LANGUAGE plpgsql;

-- 4. ELIMINAR/ANULAR VENTA (VENT-05 - Devoluciones)
-- Anula la venta y DEVUELVE el stock automáticamente.
CREATE OR REPLACE FUNCTION fn_anular_venta(
    p_venta_id VARCHAR,
    p_motivo VARCHAR,
    p_usuario_id INTEGER,
    p_usuario_nombre VARCHAR
) RETURNS BOOLEAN AS $$
DECLARE
    v_auditoria_id VARCHAR;
    rec RECORD;
BEGIN
    -- Validar
    IF NOT EXISTS (SELECT 1 FROM public.ventas WHERE id = p_venta_id AND estadoa = true) THEN
        RAISE EXCEPTION 'Venta no encontrada o ya anulada.';
    END IF;

    v_auditoria_id := fn_registrar_auditoria(p_usuario_nombre, 'VENTAS', 'ANULAR', 'ID: ' || p_venta_id || ' Motivo: ' || p_motivo);

    -- RESTAURAR STOCK (Iterar detalles)
    FOR rec IN SELECT producto_id, cantidad FROM public.detalle_ventas WHERE venta_id = p_venta_id
    LOOP
        PERFORM fn_registrar_movimiento_stock(
            rec.producto_id,
            'ENTRADA', -- Vuelve a entrar
            rec.cantidad,
            NULL, NULL,
            'Anulación ' || p_venta_id,
            'Anulación de Venta',
            p_usuario_id,
            v_auditoria_id
        );
    END LOOP;

    -- Baja lógica
    UPDATE public.ventas SET estadoa = false, auditoria_id = v_auditoria_id WHERE id = p_venta_id;
    UPDATE public.pagos SET estadoa = false WHERE venta_id = p_venta_id;

    RETURN TRUE;
END;
$$ LANGUAGE plpgsql;


-- Auxiliar: Calcular cuánto dinero hay en sistema
CREATE OR REPLACE FUNCTION fn_calcular_sistema_caja(
    p_usuario_id INTEGER
) RETURNS NUMERIC AS $$
DECLARE
    v_total NUMERIC;
BEGIN
    -- Suma pagos en efectivo del día actual para ese usuario
    SELECT COALESCE(SUM(p.importe - p.vuelto), 0) INTO v_total
    FROM public.pagos p
    JOIN public.ventas v ON p.venta_id = v.id
    WHERE v.usuario_id = p_usuario_id
      AND v.fecha_hora::DATE = CURRENT_DATE
      AND p.medio = 'EFECTIVO'
      AND v.estadoa = true;
      
    RETURN v_total;
END;
$$ LANGUAGE plpgsql;

-- 1. CREAR CIERRE (VENT-05)
CREATE OR REPLACE FUNCTION fn_crear_cierre_caja(
    p_usuario_id INTEGER,
    p_efectivo_fisico NUMERIC, -- Lo que contó el cajero
    p_observaciones TEXT,
    p_usuario_auditoria VARCHAR
) RETURNS VARCHAR AS $$
DECLARE
    v_cierre_id VARCHAR;
    v_auditoria_id VARCHAR;
    v_sistema NUMERIC;
    v_diferencia NUMERIC;
BEGIN
    v_sistema := fn_calcular_sistema_caja(p_usuario_id);
    v_diferencia := p_efectivo_fisico - v_sistema;

    v_auditoria_id := fn_registrar_auditoria(p_usuario_auditoria, 'CAJA', 'CIERRE', 'Dif: ' || v_diferencia);
    v_cierre_id := gen_random_uuid()::text;

    INSERT INTO public.cierre_caja (
        id, usuario_id, fecha, hora_cierre, total_efectivo, diferencia, observaciones, auditoria_id
    ) VALUES (
        v_cierre_id, p_usuario_id, CURRENT_DATE, CURRENT_TIME, p_efectivo_fisico, v_diferencia, p_observaciones, v_auditoria_id
    );

    RETURN v_cierre_id;
END;
$$ LANGUAGE plpgsql;

-- 2. LEER CIERRES (Historial)
CREATE OR REPLACE FUNCTION fn_leer_cierres_caja(
    p_fecha DATE DEFAULT NULL
) RETURNS TABLE (
    id VARCHAR, usuario INTEGER, hora TIME, efectivo NUMERIC, diferencia NUMERIC
) AS $$
BEGIN
    RETURN QUERY
    SELECT c.id, c.usuario_id, c.hora_cierre, c.total_efectivo, c.diferencia
    FROM public.cierre_caja c
    WHERE c.estadoa = true
    AND (p_fecha IS NULL OR c.fecha = p_fecha)
    ORDER BY c.fecha DESC, c.hora_cierre DESC;
END;
$$ LANGUAGE plpgsql;

-- 3. ACTUALIZAR CIERRE (Solo observaciones)
CREATE OR REPLACE FUNCTION fn_actualizar_cierre_observacion(
    p_cierre_id VARCHAR,
    p_observaciones TEXT,
    p_usuario_auditoria VARCHAR
) RETURNS BOOLEAN AS $$
DECLARE
    v_auditoria_id VARCHAR;
BEGIN
    v_auditoria_id := fn_registrar_auditoria(p_usuario_auditoria, 'CAJA', 'EDITAR', 'ID: ' || p_cierre_id);
    
    UPDATE public.cierre_caja 
    SET observaciones = p_observaciones, auditoria_id = v_auditoria_id 
    WHERE id = p_cierre_id;
    
    RETURN FOUND;
END;
$$ LANGUAGE plpgsql;

-- 4. ELIMINAR CIERRE (Lógico - Caso raro, ej: error de usuario)
CREATE OR REPLACE FUNCTION fn_eliminar_cierre_caja(
    p_cierre_id VARCHAR,
    p_usuario_auditoria VARCHAR
) RETURNS BOOLEAN AS $$
DECLARE
    v_auditoria_id VARCHAR;
BEGIN
    v_auditoria_id := fn_registrar_auditoria(p_usuario_auditoria, 'CAJA', 'ELIMINAR', 'ID: ' || p_cierre_id);
    
    UPDATE public.cierre_caja 
    SET estadoa = false, auditoria_id = v_auditoria_id 
    WHERE id = p_cierre_id;
    
    RETURN FOUND;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION fn_reporte_ventas_periodo(
    p_fecha_inicio DATE,
    p_fecha_fin DATE
) RETURNS TABLE (
    fecha DATE,
    cantidad_ventas BIGINT,
    total_vendido NUMERIC,
    promedio_ticket NUMERIC
) AS $$
BEGIN
    RETURN QUERY 
    SELECT 
        v.fecha_hora::DATE as fecha_dia,
        COUNT(*) as cantidad,
        COALESCE(SUM(v.total), 0) as total,
        COALESCE(AVG(v.total), 0) as promedio
    FROM public.ventas v
    WHERE 
        v.estadoa = true 
        AND v.fecha_hora::DATE BETWEEN p_fecha_inicio AND p_fecha_fin
    GROUP BY fecha_dia
    ORDER BY fecha_dia DESC;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION fn_reporte_productos_top(
    p_fecha_inicio DATE,
    p_fecha_fin DATE,
    p_limite INTEGER DEFAULT 10
) RETURNS TABLE (
    ranking BIGINT,
    producto TEXT,
    cantidad_total BIGINT,
    ingresos_generados NUMERIC
) AS $$
BEGIN
    RETURN QUERY 
    SELECT 
        ROW_NUMBER() OVER (ORDER BY SUM(dv.cantidad) DESC) as rank,
        p.nombre::TEXT,
        SUM(dv.cantidad) as total_unidades,
        SUM(dv.subtotal) as total_dinero
    FROM public.detalle_ventas dv
    JOIN public.ventas v ON dv.venta_id = v.id
    JOIN public.productos p ON dv.producto_id = p.id
    WHERE 
        v.estadoa = true
        AND v.fecha_hora::DATE BETWEEN p_fecha_inicio AND p_fecha_fin
    GROUP BY p.nombre
    ORDER BY total_unidades DESC
    LIMIT p_limite;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION fn_reporte_rentabilidad(
    p_fecha_inicio DATE,
    p_fecha_fin DATE
) RETURNS TABLE (
    producto TEXT,
    precio_venta NUMERIC,
    costo_unitario NUMERIC,
    unidades_vendidas BIGINT,
    ingreso_total NUMERIC,
    costo_total NUMERIC,
    ganancia_bruta NUMERIC,
    margen_porcentaje NUMERIC
) AS $$
BEGIN
    RETURN QUERY 
    SELECT 
        p.nombre::TEXT,
        p.precio_venta,
        p.precio_costo,
        SUM(dv.cantidad) as unidades,
        SUM(dv.subtotal) as ingreso,
        SUM(dv.cantidad * p.precio_costo) as costo,
        (SUM(dv.subtotal) - SUM(dv.cantidad * p.precio_costo)) as ganancia,
        CASE 
            WHEN SUM(dv.subtotal) = 0 THEN 0 
            ELSE ROUND(((SUM(dv.subtotal) - SUM(dv.cantidad * p.precio_costo)) / SUM(dv.subtotal)) * 100, 2)
        END as margen
    FROM public.detalle_ventas dv
    JOIN public.ventas v ON dv.venta_id = v.id
    JOIN public.productos p ON dv.producto_id = p.id
    WHERE 
        v.estadoa = true
        AND v.fecha_hora::DATE BETWEEN p_fecha_inicio AND p_fecha_fin
    GROUP BY p.id, p.nombre, p.precio_venta, p.precio_costo
    ORDER BY ganancia DESC;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION fn_reporte_inventario_valorado() 
RETURNS TABLE (
    categoria TEXT,
    cantidad_productos BIGINT,
    stock_total BIGINT,
    valor_costo_total NUMERIC,
    valor_venta_potencial NUMERIC
) AS $$
BEGIN
    RETURN QUERY 
    SELECT 
        c.nombre::TEXT,
        COUNT(p.id) as items,
        SUM(p.stock_actual) as stock,
        SUM(p.stock_actual * p.precio_costo) as valor_costo,
        SUM(p.stock_actual * p.precio_venta) as valor_venta
    FROM public.productos p
    JOIN public.categorias c ON p.categoria_id = c.id
    WHERE p.estadoa = true
    GROUP BY c.nombre
    ORDER BY valor_costo DESC;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION fn_alerta_stock_bajo() 
RETURNS TABLE (
    producto_id VARCHAR,
    producto TEXT,
    proveedor TEXT,
    stock_actual INTEGER,
    stock_minimo INTEGER,
    faltante INTEGER
) AS $$
BEGIN
    RETURN QUERY 
    SELECT 
        p.id,
        p.nombre::TEXT,
        prov.razon_social::TEXT,
        p.stock_actual,
        p.stock_minimo,
        (p.stock_minimo - p.stock_actual) as deficit
    FROM public.productos p
    LEFT JOIN public.proveedores prov ON p.proveedor_principal_id = prov.id
    WHERE 
        p.estadoa = true 
        AND p.stock_actual <= p.stock_minimo
    ORDER BY deficit DESC;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION fn_alerta_vencimientos(
    p_dias_anticipacion INTEGER DEFAULT 30
) RETURNS TABLE (
    producto TEXT,
    lote TEXT,
    fecha_vencimiento DATE,
    dias_restantes INTEGER,
    estado_alerta TEXT -- 'ROJO', 'AMARILLO', 'VERDE'
) AS $$
BEGIN
    RETURN QUERY 
    SELECT 
        p.nombre::TEXT,
        r.lote::TEXT,
        r.fecha_vencimiento,
        (r.fecha_vencimiento - CURRENT_DATE)::INTEGER as dias,
        CASE 
            WHEN (r.fecha_vencimiento - CURRENT_DATE) <= 15 THEN 'ROJO'
            WHEN (r.fecha_vencimiento - CURRENT_DATE) <= 20 THEN 'AMARILLO'
            ELSE 'VERDE'
        END as semaforo
    FROM public.recepciones r
    JOIN public.detalle_orden_compra doc ON r.orden_id = doc.orden_id -- Relación para llegar al producto
    JOIN public.productos p ON doc.producto_id = p.id
    WHERE 
        r.fecha_vencimiento IS NOT NULL 
        AND r.fecha_vencimiento <= (CURRENT_DATE + p_dias_anticipacion)
        AND r.fecha_vencimiento >= CURRENT_DATE -- No mostrar ya vencidos hace años
    ORDER BY r.fecha_vencimiento ASC;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION fn_leer_auditoria(
    p_usuario TEXT DEFAULT NULL,
    p_modulo TEXT DEFAULT NULL,
    p_fecha_inicio DATE DEFAULT NULL,
    p_fecha_fin DATE DEFAULT NULL,
    p_limite INTEGER DEFAULT 100
) RETURNS TABLE (
    fecha TIMESTAMP,
    usuario TEXT,
    modulo TEXT,
    accion TEXT,
    detalles TEXT
) AS $$
BEGIN
    RETURN QUERY 
    SELECT 
        a.fecha_hora,
        a.usuario::TEXT,
        a.modulo::TEXT,
        a.accion::TEXT,
        a.detalles::TEXT
    FROM public.auditoria a
    WHERE 
        (p_usuario IS NULL OR a.usuario ILIKE '%' || p_usuario || '%')
        AND (p_modulo IS NULL OR a.modulo = p_modulo)
        AND (p_fecha_inicio IS NULL OR a.fecha_hora::DATE >= p_fecha_inicio)
        AND (p_fecha_fin IS NULL OR a.fecha_hora::DATE <= p_fecha_fin)
    ORDER BY a.fecha_hora DESC
    LIMIT p_limite;
END;
$$ LANGUAGE plpgsql;


-- Procedimiento especializado para login
CREATE OR REPLACE FUNCTION fn_autenticar_usuario(
    p_username VARCHAR,
    p_password_hash VARCHAR
) RETURNS TABLE (
    usuario_id INTEGER,
    username VARCHAR,
    empleado_id VARCHAR,
    rol_nombre VARCHAR,
    cargo_nombre VARCHAR
) AS $$
BEGIN
    RETURN QUERY 
    SELECT 
        u.id,
        u.username,
        u.empleado_id,
        r.nombre as rol_nombre,
        c.nombre as cargo_nombre
    FROM public.usuarios u
    JOIN public.roles r ON u.rol_id = r.id
    JOIN public.empleados e ON u.empleado_id = e.id
    JOIN public.cargos c ON e.cargo_id = c.id
    WHERE u.username = p_username 
      AND u.password_hash = p_password_hash
      AND u.estado = 'ACTIVO'
      AND u.estadoa = true;
END;
$$ LANGUAGE plpgsql;

-- Procedimiento para obtener datos completos del usuario
CREATE OR REPLACE FUNCTION fn_obtener_datos_usuario(
    p_usuario_id INTEGER
) RETURNS JSON AS $$
DECLARE
    v_result JSON;
BEGIN
    SELECT json_build_object(
        'usuario_id', u.id,
        'username', u.username,
        'rol', r.nombre,
        'empleado', json_build_object(
            'id', e.id,
            'nombres', e.nombres,
            'apellido_paterno', e.apellido_paterno,
            'cargo', c.nombre
        )
    ) INTO v_result
    FROM public.usuarios u
    JOIN public.roles r ON u.rol_id = r.id
    JOIN public.empleados e ON u.empleado_id = e.id
    JOIN public.cargos c ON e.cargo_id = c.id
    WHERE u.id = p_usuario_id;
    
    RETURN v_result;
END;
$$ LANGUAGE plpgsql;